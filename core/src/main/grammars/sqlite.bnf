{
  parserClass = "com.alecstrong.sqlite.psi.core.parser.SqliteParser"
  elementTypeClass = "com.alecstrong.sqlite.psi.core.SqliteElementType"

  implements="com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  extends="com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElementImpl"

  psiClassPrefix = "Sqlite"
  psiImplClassSuffix = "Impl"
  psiPackage = "com.alecstrong.sqlite.psi.core.psi"
  psiImplPackage = "com.alecstrong.sqlite.psi.core.psi.impl"

  tokens=[
    SEMI=';'
    EQ='='
    LP='('
    RP=')'
    DOT='.'
    COMMA=','

    space='regexp:\s+'
    comment='regexp:--.*'
    digit='regexp:\d+(\.\d*)?'
    id='regexp:([a-zA-Z0-9_])*'
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
  ]
  extends(".*expr")=expr
}

sql_stmt_list ::= [ sql_stmt ] ( ';' [ sql_stmt ] ) * {
  mixin="com.alecstrong.sqlite.psi.core.psi.mixins.SqlStmtListMixin"
}
sql_stmt ::= [ EXPLAIN [ QUERY PLAN ] ] ( alter_table_stmt | analyze_stmt | attach_stmt | begin_stmt | commit_stmt | create_index_stmt | create_table_stmt | create_trigger_stmt | create_view_stmt | create_virtual_table_stmt | delete_stmt | delete_stmt_limited | detach_stmt | drop_index_stmt | drop_table_stmt | drop_trigger_stmt | drop_view_stmt | insert_stmt | pragma_stmt | reindex_stmt | release_stmt | rollback_stmt | savepoint_stmt | compound_select_stmt | update_stmt | update_stmt_limited | vacuum_stmt )
alter_table_stmt ::= ALTER TABLE [ database_name '.' ] table_name ( RENAME TO new_table_name | ADD [ COLUMN ] column_def )
analyze_stmt ::= ANALYZE [ database_name | table_or_index_name | database_name '.' table_or_index_name ]
attach_stmt ::= ATTACH [ DATABASE ] expr AS database_name
begin_stmt ::= BEGIN [ DEFERRED | IMMEDIATE | EXCLUSIVE ] [ TRANSACTION ]
commit_stmt ::= ( COMMIT | END ) [ TRANSACTION ]
rollback_stmt ::= ROLLBACK [ TRANSACTION ] [ TO [ SAVEPOINT ] savepoint_name ]
savepoint_stmt ::= SAVEPOINT savepoint_name
release_stmt ::= RELEASE [ SAVEPOINT ] savepoint_name
create_index_stmt ::= CREATE [ UNIQUE ] INDEX [ IF NOT EXISTS ] [ database_name '.' ] index_name ON table_name '(' indexed_column ( ',' indexed_column ) * ')' [ WHERE expr ]
indexed_column ::= column_name [ COLLATE collation_name ] [ ASC | DESC ]
create_table_stmt ::= CREATE [ TEMP | TEMPORARY ] TABLE [ IF NOT EXISTS ] [ database_name '.' ] table_name ( '(' column_def ( ',' column_def ) * ( ',' table_constraint ) * ')' [ WITHOUT ROWID ] | AS compound_select_stmt )
column_def ::= column_name [ type_name ] ( column_constraint ) *
type_name ::= identifier [ '(' signed_number ')' | '(' signed_number ',' signed_number ')' ]
column_constraint ::= [ CONSTRAINT identifier ] ( PRIMARY KEY [ ASC | DESC ] conflict_clause [ AUTOINCREMENT ] | NOT NULL conflict_clause | UNIQUE conflict_clause | CHECK '(' expr ')' | DEFAULT ( signed_number | literal_value | '(' expr ')' ) | COLLATE collation_name | foreign_key_clause )
signed_number ::= [ '+' | '-' ] numeric_literal
table_constraint ::= [ CONSTRAINT identifier ] ( ( PRIMARY KEY | UNIQUE ) '(' indexed_column ( ',' indexed_column ) * ')' conflict_clause | CHECK '(' expr ')' | FOREIGN KEY '(' column_name ( ',' column_name ) * ')' foreign_key_clause )
foreign_key_clause ::= REFERENCES foreign_table [ '(' column_name ( ',' column_name ) * ')' ] [ ( ON ( DELETE | UPDATE ) ( SET NULL | SET DEFAULT | CASCADE | RESTRICT | NO ACTION ) | MATCH identifier ) ] [ [ NOT ] DEFERRABLE [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ] ]
conflict_clause ::= [ ON CONFLICT ( ROLLBACK | ABORT | FAIL | IGNORE | REPLACE ) ]
create_trigger_stmt ::= CREATE [ TEMP | TEMPORARY ] TRIGGER [ IF NOT EXISTS ] [ database_name '.' ] trigger_name [ BEFORE | AFTER | INSTEAD OF ] ( DELETE | INSERT | UPDATE [ OF column_name ( ',' column_name ) * ] ) ON table_name [ FOR EACH ROW ] [ WHEN expr ] BEGIN ( update_stmt | insert_stmt | delete_stmt | compound_select_stmt ) ';' END
create_view_stmt ::= CREATE [ TEMP | TEMPORARY ] VIEW [ IF NOT EXISTS ] [ database_name '.' ] view_name AS compound_select_stmt
create_virtual_table_stmt ::= CREATE VIRTUAL TABLE [ IF NOT EXISTS ] [ database_name '.' ] table_name USING module_name [ '(' module_argument ( ',' module_argument ) * ')' ]
with_clause ::= WITH [ RECURSIVE ] cte_table_name AS '(' compound_select_stmt ')' ( ',' cte_table_name AS '(' compound_select_stmt ')' ) *
cte_table_name ::= table_name [ '(' column_alias ( ',' column_alias ) * ')' ]
common_table_expression ::= table_name [ '(' column_alias ( ',' column_alias ) * ')' ] AS '(' compound_select_stmt ')' {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.CommonTableExpressionMixin"
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteQueryElement"
}
delete_stmt ::= [ with_clause ] DELETE FROM qualified_table_name [ WHERE expr ]
delete_stmt_limited ::= [ with_clause ] DELETE FROM qualified_table_name [ WHERE expr ] [ [ ORDER BY ordering_term ( ',' ordering_term ) * ] LIMIT expr [ ( OFFSET | ',' ) expr ] ]
detach_stmt ::= DETACH [ DATABASE ] database_name
drop_index_stmt ::= DROP INDEX [ IF EXISTS ] [ database_name '.' ] index_name
drop_table_stmt ::= DROP TABLE [ IF EXISTS ] [ database_name '.' ] table_name
drop_trigger_stmt ::= DROP TRIGGER [ IF EXISTS ] [ database_name '.' ] trigger_name
drop_view_stmt ::= DROP VIEW [ IF EXISTS ] [ database_name '.' ] view_name
expr ::= ( raise_expr
         | case_expr
         | exists_expr
         | in_expr
         | between_expr
         | is_expr
         | null_expr
         | like_expr
         | collate_expr
         | cast_expr
         | paren_expr
         | function_expr
         | binary_expr
         | unary_expr
         | bind_expr
         | column_expr
         | literal_expr )

literal_expr ::= literal_value
bind_expr ::= bind_parameter
column_expr ::= [ [ database_name '.' ] table_name '.' ] column_name
unary_expr ::= ('+' | '-') expr
binary_expr ::= expr ( '+' | '_' | '*' | '/' | '=' | '<>' | '==' | '<' | '>' | '<=' | '>=' ) expr
function_expr ::= function_name '(' [ [ DISTINCT ] expr ( ',' expr ) * | '*' ] ')'
paren_expr ::= '(' expr ')'
cast_expr ::= CAST '(' expr AS type_name ')'
collate_expr ::= expr COLLATE collation_name
like_expr ::= expr [ NOT ] ( LIKE | GLOB | REGEXP | MATCH ) expr [ ESCAPE expr ]
null_expr ::= expr ( ISNULL | NOTNULL | NOT NULL )
is_expr ::= expr IS [ NOT ] expr
between_expr ::= expr [ NOT ] BETWEEN expr AND expr
in_expr ::= expr [ NOT ] IN ( '(' [ compound_select_stmt | expr ( ',' expr ) * ] ')' | [ database_name '.' ] table_name )
exists_expr ::= [ [ NOT ] EXISTS ] '(' compound_select_stmt ')'
case_expr ::= CASE [ expr ] WHEN expr THEN expr [ ELSE expr ] END
raise_expr ::= raise_function
raise_function ::= RAISE '(' ( IGNORE | ( ROLLBACK | ABORT | FAIL ) ',' error_message ) ')'
literal_value ::= ( numeric_literal
                  | string_literal
                  | blob_literal
                  | NULL
                  | CURRENT_TIME
                  | CURRENT_DATE
                  | CURRENT_TIMESTAMP )
numeric_literal ::= ( digit [ '.' ( digit ) * ] | '.' digit ) [ E [ '+' | '-' ] digit ]
insert_stmt ::= [ with_clause ] ( INSERT | REPLACE | INSERT OR REPLACE | INSERT OR ROLLBACK | INSERT OR ABORT | INSERT OR FAIL | INSERT OR IGNORE ) INTO [ database_name '.' ] table_name [ '(' column_name ( ',' column_name ) * ')' ] ( VALUES '(' expr ( ',' expr ) * ')' ( ',' '(' expr ( ',' expr ) * ')' ) * | compound_select_stmt | DEFAULT VALUES )
pragma_stmt ::= PRAGMA [ database_name '.' ] pragma_name [ '=' pragma_value | '(' pragma_value ')' ]
pragma_value ::= ( signed_number
                 | identifier
                 | string_literal )
reindex_stmt ::= REINDEX [ collation_name | [ database_name '.' ] ( table_name | index_name ) ]
compound_select_stmt ::= [ WITH [ RECURSIVE ] common_table_expression ( ',' common_table_expression ) * ] select_stmt  ( compound_operator select_stmt ) * [ ORDER BY ordering_term ( ',' ordering_term ) * ] [ LIMIT expr [ ( OFFSET | ',' ) expr ] ] {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.CompoundSelectStmtMixin"
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteQueryElement"
}
select_stmt ::= ( SELECT [ DISTINCT | ALL ] result_column ( ',' result_column ) * [ FROM ( table_or_subquery ( ',' table_or_subquery ) * | join_clause ) ] [ WHERE expr ] [ GROUP BY expr ( ',' expr ) * [ HAVING expr ] ] | VALUES '(' expr ( ',' expr ) * ')' ( ',' '(' expr ( ',' expr ) * ')' ) * ) {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.SelectStmtMixin"
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteQueryElement"
}
join_clause ::= table_or_subquery [ join_operator table_or_subquery join_constraint ] {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.JoinClauseMixin"
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteQueryElement"
}
table_or_subquery ::= ( [ database_name '.' ] table_name [ [ AS ] table_alias ] [ INDEXED BY index_name | NOT INDEXED ]
                      | '(' ( table_or_subquery ( ',' table_or_subquery ) * | join_clause ) ')'
                      | '(' compound_select_stmt ')' [ [ AS ] table_alias ] ) {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.TableOrSubqueryMixin"
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteQueryElement"
}
result_column ::= ( '*'
                  | table_name '.' '*'
                  | expr [ [ AS ] column_alias ] ) {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.ResultColumnMixin"
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteQueryElement"
}
join_operator ::= ( ','
                  | [ NATURAL ] [ LEFT [ OUTER ] | INNER | CROSS ] JOIN )
join_constraint ::= [ ON expr | USING '(' column_name ( ',' column_name ) * ')' ]
ordering_term ::= expr [ COLLATE collation_name ] [ ASC | DESC ]
compound_operator ::= ( UNION
                      | UNION ALL
                      | INTERSECT
                      | EXCEPT )
update_stmt ::= [ with_clause ] UPDATE [ OR ROLLBACK | OR ABORT | OR REPLACE | OR FAIL | OR IGNORE ] qualified_table_name SET column_name '=' expr ( ',' column_name '=' expr ) * [ WHERE expr ]
update_stmt_limited ::= [ with_clause ] UPDATE [ OR ROLLBACK | OR ABORT | OR REPLACE | OR FAIL | OR IGNORE ] qualified_table_name SET column_name '=' expr ( ',' column_name '=' expr ) * [ WHERE expr ] [ [ ORDER BY ordering_term ( ',' ordering_term ) * ] LIMIT expr [ ( OFFSET | ',' ) expr ] ]
qualified_table_name ::= [ database_name '.' ] table_name [ INDEXED BY index_name | NOT INDEXED ]
vacuum_stmt ::= VACUUM
table_name ::= id {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.TableNameMixin"
  implements = "com.intellij.psi.PsiNamedElement"
}
database_name ::= id
index_name ::= id
column_name ::= id {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.ColumnNameMixin"
  implements = "com.intellij.psi.PsiNamedElement"
}
column_alias ::= id {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.ColumnAliasMixin"
  implements = [
    "com.alecstrong.sqlite.psi.core.psi.SqliteAliasElement",
    "com.intellij.psi.PsiNamedElement"
  ]
}
table_alias ::= id {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.TableAliasMixin"
  implements = [
    "com.intellij.psi.PsiNamedElement",
    "com.alecstrong.sqlite.psi.core.psi.SqliteAliasElement"
  ]
}
foreign_table ::= id
identifier ::= id
pragma_name ::= id
function_name ::= id
string_literal ::= string
table_or_index_name ::= id
new_table_name ::= id
savepoint_name ::= id
trigger_name ::= id
blob_literal ::= '0x' digit
collation_name ::= id
error_message ::= string
view_name ::= id {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.TableNameMixin"
  implements = "com.intellij.psi.PsiNamedElement"
}
module_name ::= id
bind_parameter ::= ( '?' [digit] | ':' identifier )
